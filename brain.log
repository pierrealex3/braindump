*** IntelliJ // shortcuts

Ctrl-Alt-B	-> go to impl


*** Java // Spring Boot // specify maps in config

// application.properties
org.pa.api.feat.this=true
org.pa.api.feat.that=false

// code
@ConfigurationProperties(prefix="org.pa.feat")
Map<String, Boolean> featMap;


*** Java // Spring Boot // typical web security class

@EnableWebSecurity
@ConditionalOnProperty(prefix="prop.prefix", name="suffix", havingValue=true|false)
public class SecurityConfig extends WebSecurityConfigurerAdapter

@Override
// the infamous allow..deny..scope..uripattern method


*** Java // Spring Boot // typical controller advice to handle exceptions in a web app

@ControllerAdvice
@RestController // truly required??
public class

@ExceptionHandler(MyRuntimeException.class)
@ResponseStatus(value=HttpStatus.BAD_REQUEST)
@ResponseBody // truly required??
public ResponseEntity<MyBody> handlerMethod( HttpServletRequest req, HttpServletResponse res, MyRuntimeException ex)


*** Java // Spring Boot // access to locale resource bundles (english, french message files)

ResourceBundleMessageSource r;	// autowired
var locale = LocaleContextHolder.getLocale();	// I guess that's a ThreadLocal mechanism coming with a setLocale
String msg = s.getMessage(code, args, locale);


*** Java // String format // display percentage and dollar sign
BigDecimal per = ...
BigDecimal amt = ...
String.format("This is percentage: %s%% and this is amount %s$", per, amt);


*** Java // String format // left and right pad with 0's
%05d -> 5 digit number left-padded with 0's ex: 00115
%.6f -> up to 6 digits after the period, right-padded with 0's ex: 22.560000


*** Java // String format // positional arg reference
String.format("Hello my %1$s %1$s", "friend"); // Hello my friend friend


** AWS // VPC // VPC Setup: allow for outside-world communication
To allow components running in a VPC subnet to communicate with the outside world, an explicit IP route must be added.
To do so: In the VPC subnet's route table, add a route with "Destination" 0.0.0.0/0 (aka everywhere) associated to an internet gateway "Target".


** AWS // EC2 // EC2 Setup: provision an IP address
Create an Elastic IP address and associate it to the private IP address of your EC2 instance
To do so: In AWS web, from the Elastic IPs menu of EC2


** AWS // EC2 // Connect to EC2
For this:
* your EC2 needs to have a public IP assigned
* you need to have the key pair (.pem) file at hand
* the SSH connection must be allowed in the VPC subnet (by default, it is)

$ ssh -i ~/Downloads/cryptobang-keys.pem ec2-user@3.138.76.40


** AWS // EC2 // Install basic software on a newly created EC2 (Amazon Linux)

$ sudo yum update
$ sudo amazon-linux-extras install java-openjdk11
// use the alternatives command-line utility in case there is more than one version of java installed.  This is great.
$ alternatives --config java


** AWS // EC2 // Transfer (scp) stuff over to the EC2 instance

$ scp -r -i ~/Downloads/cryptobang-keys.pem ./crashWire-0.0.1-SNAPSHOT.jar ec2-user@3.138.76.40:/home/ec2-user
crashWire-0.0.1-SNAPSHOT.jar 


** AWS // EC2 // Run a spring boot app on the EC2 instance (not forgetting AWS credentials)
I had to:
1) create an IAM role (cryptobang-iam-role)
2) then provision it with AmazonSNSFullAccess Policy (reference below)
3) then assign the EC2 instance with the created IAM role
Policy reference -> https://console.aws.amazon.com/iam/home?region=us-east-1#/policies/arn%3Aaws%3Aiam%3A%3Aaws%3Apolicy%2FAmazonSNSFullAccess

$ java -Dspring.profiles.active=smstest -jar crashWire-0.0.1-SNAPSHOT.jar > logs.out &


** AWS // blockchain // Hyperledger Fabric Network: inspect and run artifacts created by running the AWS Blockchain Template
// logon to the EC2 where all the Network participants (peer, orderer, explorer, ledger) are running

// directory for yaml files that were used to provision containerized components (created by the AWS Blockchain Template)
$ cd ~/HyperLedger-BasicNetwork/artifacts/docker-compose

// view all containers -and their status- that were created using the specified (master) yaml file
$ docker-compose -f docker-compose-cli.yaml ps

// bring up containers using docker-compose
IMAGE_TAG=latest 	-> env var to instruct docker-compose to pick-up the latest image for every container it must start
-f					-> the root yaml file to parse
up					-> bring the target container(s) up
-d					-> run this command in the background
--no-deps			-> do not cover the dependent containers
cli					-> this is the target container as defined in the yaml file

$ IMAGE_TAG=latest docker-compose -f docker-compose-cli.yaml up -d --no-deps cli

// log into the command line interface (cli) container
exec				-> connects us to the container specified rightafter (cli)
bash				-> executes the bash shell on the targeted container
$ docker-compose -f docker-compose-cli.yaml exec cli bash


** AWS // blockchain docker // Hyperledger Fabric Network: copy a chaincode file into the cli container

cli:/opt/gopath/src/github.com/chaincode	-> cli: is the target container, /opt/... is the path on the container to copy the file to
$ docker cp car_registry.go cli:/opt/gopath/src/github.com/chaincode


** AWS // blockchain docker // Hyperledger Fabric Network: log into the cli container
-it		-> interactive mode
$ docker exec -it cli bash


** AWS // blockchain // Hyperledger Fabric Network: install chaincode (ex: a .go program) on a targeted peer node
// at this point we are logged into the cli container!
PEER env var are referencing the targeted peer
-n mydapp			-> a name for the chaincode smart contract
-v 1.0				-> a version for THIS chaincode
-p 					-> a path relative to $GOPATH/src/ where the root of the chaincode is located

$ peer chaincode install -n mydapp -v 1.0 -p github.com/chaincode/


** AWS // blockchain // Hyperledger Fabric Network: list chaincodes that are installed on peers
// at this point we are logged into the cli container!
note: they are installed but not necessarily instantiated yet

$ peer chaincode list --installed


** AWS // blockchain // Hyperledger Fabric Network: enable TLS communication between peers and orderer nodes
// at this point we are logged into the cli container!
// NOTE: it's about setting the env var ORDERER_CA to the path of a .pem file, used for TLS.
   The command is not very clear in pluralsight course but it seems to be something LIKE:
   
$ export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tls/a.example.com-cert.pem


** AWS // blockchain // Hyperledger Fabric Network: instantiate the chaincode we created
// at this point we are logged into the cli container!
-o			-> orderer to be used by the chaincode
--tls		-> specify the tls certificate for communication on the network
-C			-> public channel used for communication (specified at the AWS Blockchain template creation time?)
-n			-> target chaincode smart contract name that was installed on a peer (ref: peer chaincode install)
-v			-> "" along with its version...
-c			-> args to init method of target chaincode

$ peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile $ORDERER_CA -C mychannel -n mydapp -v 1.0 -c '{"Args": []}'


** AWS // blockchain // Hyperledger Fabric Network: invoke chaincode we created
// at this point we are logged into the cli container!
for params meaning, refer: Hyperledger Fabric Network: instantiate the chaincode we created
-c		-> this represents the params passed to the invoke method of the mydapp smart contract

$ peer chaincode invoke -o orderer.example.com:7050 --tls --cafile $ORDERER_CA -C mychannel -n mydapp -c '{"Args":["createCar", "CAR01", "Volkswagen", "Passat", "yellow", "Max"]}'


** AWS // blockchain // Hyperledger Fabric Network: query chaincode we created
// at this point we are logged into the cli container!
Note: it will NOT generate a transaction - the peer will only query its own state of the ledger

$ peer chaincode query -C mychannel -n mydapp -c '{"Args": ["queryCar", "CAR01"]}'


*** React // feature | libs summary

Testing:			Jest, Mocha
Http lib:			Fetch, Axios
Routing:			React Router
I18N:				react-intl
Animation:			react-motion
Form validatoin:	react-forms
CLI:				create-react-apps


*** React // 5 keys decisions to take up-front

* Dev environment (create-react-app to get started ?)
* classes or functions
* how to handle types (PropTypes or TypeScript ?)
* how to handle state (Plain React, Flux, Redux or MobX ?)
* how to handle styling (css, sass, less ?)


*** crypto // generate a PKCS12 keystore with a self signed certificate in it - with keytool

$ keytool -genkeypair -alias cryptobalance -keystore localhost_orgpaks.pfx -storetype PKCS12 -keyalg RSA -storepass Kodak123 -validity 36500 -keysize 2048


*** crypto // view entries (certificate fingerprint) in a key storepass

$ keytool -list -keystore localhost_orgpaks.pfx


*** curl // https // ignore the non legit (ex: self-signed) certificate

$ curl -k -s https://localhost:8443/blabla


*** curl // POST

-i -> include response headers
-s -> shhhht...
-k -> accept non-legit certs
-u -> Basic Auth
$ curl -X POST -i -s -k -u 'Pietro:CoucouMonTiChou' https://localhost:8443/crypto/balance/treasury
$ curl -X POST -i -k -s -u 'Pietro:CoucouMonTiChou' https://ec2-3-138-76-40.us-east-2.compute.amazonaws.com:8443/crypto/balance/treasury/registrations

** post with data

-H -> Content-Type header is usually mandatory
--data -> refer to data on file
$ curl  -i -s -X POST -H "Content-Type: application/json" --data "@/c/temp/data.json" http://...


*** grep // kool commands
inverse grep
$ grep -v FILTEROUT


*** Spring HTTPS // minimal setup

server.port=8443
server.ssl.enabled=true
server.ssl.key-alias=cryptobalance
server.ssl.key-store=classpath:localhost_orgpaks.pfx
server.ssl.key-store-password=Kodak123

